import { DatabaseSync, SQLOutputValue } from "node:sqlite";
import { EnrollType } from "../enrollment/enroll";
import { readFileSync } from "node:fs";

/**
 * A basic class to setup a small sqlite database when endpoints enroll
 */
export class LocalSqlite {
    private path: string;
    private db: DatabaseSync;

    /**
     * Create new local sqlite database
     * @param path Path the persist the sqlite DatabaseSync
     */
    constructor (path: string) {
        this.path = path;
        this.db = new DatabaseSync(this.path);

        this.setupTables();
    }

    /**
     * Function to track endpoints that enroll into our small server
     * @param data `EnrollType` information
     * @param node_key The unique endpoint key generated by the server
     */
    public insertEndpoint(data: EnrollType, node_key: string): void {
        const insert = this.db.prepare(`INSERT INTO endpoints (node_key, endpoint_id, platform, hostname, ip, version, info) VALUES (?, ?, ?, ?, ?, ?, ?)`);
        const status = insert.run(node_key, data.endpoint_id, data.info.platform, data.info.hostname, data.info.interfaces.at(0)?.ip ?? "", data.info.os_version, JSON.stringify(data.info));
        console.info(`Added endpoint to db ${JSON.stringify(status)}`);
    }

    /**
     * Get list of enrolled endpoints
     * @returns Array of rows from `endpoints` table
     */
    public listEndpoints(): Record<string, SQLOutputValue>[] {
        const query = this.db.prepare(`SELECT * FROM endpoints`);
        const values = query.all();
        return values;
    }

    /**
     * Function to create a new collection against an endpoint
     * @param node_key The unique endpoint key generated by the server
     * @param collection_id The unique collection id for the collection
     */
    public newCollection(node_key: string, collection_id: number): void {
        const insert = this.db.prepare(`INSERT INTO collections (node_key, collection_id, status) VALUES (?, ?, ?)`);
        insert.run(node_key, collection_id, "Not Started");
    }

    /**
     * Function to check if we have any collections we need to run against out endpoint
     * @param node_key The unique endpoint key generated by the server
     * @returns Collection script and ID object or undefined
     */
    public getCollections(node_key: string): { script: string, collection_id: number; } | undefined {
        const query = this.db.prepare(`SELECT script, collections.collection_id AS collection_id FROM collections INNER JOIN collection_scripts where node_key = ? AND status = 'Not Started' AND collection_scripts.collection_id = collections.collection_id`);
        const status = query.get(node_key);
        if (status === undefined) {
            return status;
        }

        const script = status[ "script" ];
        const collection_id = status[ "collection_id" ];
        if (typeof script === 'string' && typeof collection_id === 'number') {
            return { script, collection_id };
        }

        return undefined;
    }

    /**
     * Function to change the collection status.
     * @param node_key The unique endpoint key generated by the server
     * @param collection_id Collection ID to update
     * @param status New collection status
     */
    public updateCollection(node_key: string, collection_id: number, status: string): void {
        const query = this.db.prepare(`UPDATE collections SET status = ? where node_key = ? AND collection_id = ?`);
        query.get(status, node_key, collection_id);
    }

    /**
     * Setup default tables for our sqlite database
     */
    private setupTables(): void {
        try {
            const endpoints = `CREATE TABLE endpoints(id INTEGER PRIMARY KEY, node_key TEXT, endpoint_id TEXT, platform TEXT, hostname TEXT, ip TEXT, version TEXT, info TEXT)`;
            this.db.exec(endpoints);

            const collections = `CREATE TABLE collections(id PRIMARY KEY, collection_id INTEGER, node_key TEXT, status TEXT)`;
            this.db.exec(collections);

            const collection_scripts = `CREATE TABLE collection_scripts(id PRIMARY KEY, collection_id INTEGER, script TEXT)`;
            this.db.exec(collection_scripts);
            this.defaultCollections();
        } catch (err: unknown) {
            if (err instanceof Error)
                console.warn(`Failed to execute table creation: ${err}`);
        }
    }

    /**
     * Setup default collections to test
     */
    private defaultCollections(): void {
        try {
            const bytes = readFileSync("./tests/collections/linux.toml");
            const encoded = bytes.toString('base64');
            const insert = this.db.prepare(`INSERT INTO collection_scripts (collection_id, script) VALUES (?, ?)`);
            insert.run(1, encoded);
        } catch (err: unknown) {
            if (err instanceof Error)
                console.warn(`Could not read file ${err}`);
        }
    }

}