import { DatabaseSync, SQLOutputValue } from "node:sqlite";
import { EnrollType } from "../enrollment/enroll";
import { readFileSync } from "node:fs";

/**
 * A basic class to setup a small sqlite database when endpoints enroll
 */
export class LocalSqlite {
    private path: string;
    private db: DatabaseSync;

    /**
     * Create new local sqlite database
     * @param path Path the persist the sqlite DatabaseSync
     */
    constructor (path: string) {
        this.path = path;
        this.db = new DatabaseSync(this.path);

        this.setupTables();
    }

    /**
     * Function to track endpoints that enroll into our small server
     * @param data `EnrollType` information
     * @param endpoint_id The unique endpoint key generated by the server
     */
    public insertEndpoint(data: EnrollType, endpoint_id: string): void {
        const insert = this.db.prepare(`INSERT INTO endpoints (endpoint_id, endpoint_uuid, platform, hostname, ip, version, info) VALUES (?, ?, ?, ?, ?, ?, ?)`);
        const status = insert.run(endpoint_id, data.endpoint_uuid, data.info.platform, data.info.hostname, data.info.interfaces.at(0)?.ip ?? "", data.info.os_version, JSON.stringify(data.info));
        console.info(`Added endpoint to db ${JSON.stringify(status)}`);
    }

    /**
     * Function to check if provided endpoint ID is found in the database
     * @param endpoint_id ID for the endpoint to check
     * @returns True if endpoint was found. False if not found
     */
    public validateEndpoint(endpoint_id: string): boolean {
        const query = this.db.prepare(`SELECT * FROM endpoints where endpoint_id = ?`);
        const values = query.get(endpoint_id);
        if (values === undefined) {
            return false;
        }

        return true;
    }

    /**
     * Get list of enrolled endpoints
     * @returns Array of rows from `endpoints` table
     */
    public listEndpoints(): Record<string, SQLOutputValue>[] {
        const query = this.db.prepare(`SELECT * FROM endpoints`);
        const values = query.all();
        return values;
    }

    /**
     * Function to create a new collection against an endpoint
     * @param endpoint_id The unique endpoint key generated by the server
     * @param collection_id The unique collection id for the collection
     */
    public newCollection(endpoint_id: string, collection_id: number): void {
        const insert = this.db.prepare(`INSERT INTO collections (endpoint_id, collection_id, status) VALUES (?, ?, ?)`);
        insert.run(endpoint_id, collection_id, "Not Started");
    }

    /**
     * Function to upload a new base64 TOML collection script
     * @param payload Base64 TOML collection payload
     * @param collection_id ID associated with the collection
     */
    public newCollectionScript(payload: string, collection_id: number): void {
        const insert = this.db.prepare(`INSERT INTO collection_scripts (collection_id, script) VALUES (?, ?)`);
        insert.run(collection_id, payload);
    }

    /**
     * Function to check if we have any collections we need to run against out endpoint
     * @param endpoint_id The unique endpoint key generated by the server
     * @returns Collection script and ID object or undefined
     */
    public getCollections(endpoint_id: string): { script: string, collection_id: number; } | undefined {
        const query = this.db.prepare(`SELECT script, collections.collection_id AS collection_id FROM collections INNER JOIN collection_scripts where endpoint_id = ? AND status = 'Not Started' AND collection_scripts.collection_id = collections.collection_id`);
        const status = query.get(endpoint_id);
        if (status === undefined) {
            return status;
        }

        const script = status[ "script" ];
        const collection_id = status[ "collection_id" ];
        if (typeof script === 'string' && typeof collection_id === 'number') {
            return { script, collection_id };
        }

        return undefined;
    }

    /**
     * Function to change the collection status.
     * @param endpoint_id The unique endpoint key generated by the server
     * @param collection_id Collection ID to update
     * @param status New collection status
     */
    public updateCollection(endpoint_id: string, collection_id: number, status: string): void {
        const query = this.db.prepare(`UPDATE collections SET status = ? where endpoint_id = ? AND collection_id = ?`);
        query.get(status, endpoint_id, collection_id);
    }

    /**
     * Setup default tables for our sqlite database
     */
    private setupTables(): void {
        try {
            const endpoints = `CREATE TABLE endpoints(id INTEGER PRIMARY KEY, endpoint_id TEXT, endpoint_uuid TEXT, platform TEXT, hostname TEXT, ip TEXT, version TEXT, info TEXT)`;
            this.db.exec(endpoints);

            const collections = `CREATE TABLE collections(id PRIMARY KEY, collection_id INTEGER, endpoint_id TEXT, status TEXT)`;
            this.db.exec(collections);

            const collection_scripts = `CREATE TABLE collection_scripts(id PRIMARY KEY, collection_id INTEGER, script TEXT)`;
            this.db.exec(collection_scripts);
            this.defaultCollections();
        } catch (err: unknown) {
            if (err instanceof Error)
                console.warn(`Failed to execute table creation: ${err}`);
        }
    }

    /**
     * Setup default collections to test
     */
    private defaultCollections(): void {
        try {
            let file = "./tests/collections/linux.toml";
            // If we are in a container use http://daemonserver domain instead of IP
            if (process.env.LISTEN !== undefined) {
                file = "./tests/collections/podman.toml";
            }
            const bytes = readFileSync(file);
            const encoded = bytes.toString('base64');
            const insert = this.db.prepare(`INSERT INTO collection_scripts (collection_id, script) VALUES (?, ?)`);
            insert.run(1, encoded);
        } catch (err: unknown) {
            if (err instanceof Error)
                console.warn(`Could not read file ${err}`);
        }
    }

}